export function buildWidgetTree(jsxTree) {
  const widgetTree = buildWidgetTreeInner(jsxTree);
  validateWidgetTree(widgetTree);
  return widgetTree;
}
function buildWidgetTreeInner(jsxTree) {
  var _jsxTree$type$process, _jsxTree$type;
  if (typeof jsxTree === 'string' || typeof jsxTree === 'number') {
    return jsxTree;
  }
  while (!jsxTree.type.__name__) {
    jsxTree = jsxTree.type(jsxTree.props);
  }
  const {
    children,
    ...otherProps
  } = jsxTree.props;
  const childrenArray = children ? Array.isArray(children) ? children : [children] : [];
  const updatedChildren = ((_jsxTree$type$process = (_jsxTree$type = jsxTree.type).processChildren) === null || _jsxTree$type$process === void 0 ? void 0 : _jsxTree$type$process.call(_jsxTree$type, otherProps, childrenArray)) ?? childrenArray ?? [];
  return {
    type: jsxTree.type.__name__,
    props: jsxTree.type.convertProps(otherProps),
    ...(updatedChildren ? {
      children: updatedChildren.filter(x => !!x).flat(1).map(x => buildWidgetTree(x)).flat(1)
    } : {})
  };
}
function validateWidgetTree(widgetTree) {
  throwIfNestedListWidget(widgetTree, false);
  const listWidgetCount = countListWidgets(widgetTree);
  if (listWidgetCount > 2) {
    throw new Error('You can have a maximum of two ListWidget(s)');
  }
}
function throwIfNestedListWidget(widgetTree) {
  let shouldThrow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (widgetTree.type === 'ListWidget') {
    if (shouldThrow) {
      throw new Error('You cannot have ListWidget inside other ListWidget');
    }
    (widgetTree.children ?? []).forEach(child => throwIfNestedListWidget(child, true));
  }
  (widgetTree.children ?? []).forEach(child => throwIfNestedListWidget(child, shouldThrow));
}
function countListWidgets(widgetTree) {
  if (widgetTree.type === 'ListWidget') {
    return 1;
  }
  return (widgetTree.children ?? []).reduce((memo, child) => memo + countListWidgets(child), 0);
}
//# sourceMappingURL=build-widget-tree.js.map